Ruby language support
=====================
- local variables
- frames
- methods
	- definition
	- call stack; call bytecode methods from bytecode methods
	- arguments: scatter args, gather args, optional args
	- multiple results
	* block args (eg (a, b, &c))
- instance variables
* call
	* trap no such method errors
	* test for -2 argc methods
	- call to super
* blocks
	- pass blocks
	- yield
	- next, break, redo, return
	* retry
	- dynamic local variables
	- pass blocks to C functions
	* ampersand parameters to methods
- class defintions
* module definitions
* get and set constants
- singleton methods
* exceptions	
	- raise
	- rescue
	- else after rescue
    	* retry
    	* integrate compilation with case statement
    	- unwind value stack along with call stack
	- catch exceptions raised in C
	- remove RAISE bytecode hack - use C method like MRI
* ensure
- throw, catch
* global variables

Ruby library support
====================
* blocks -> procs
* procs <-> methods
* blocks -> methods
* eval and friends
* method_missing
* set_trace_func
* backtrace
* threads
* continuations
* rb_frame_last_func (see rb_num_coerce_bin)
* Module.constants
* security levels
* Class.inherited and similar callbacks

Compiler
========
All the above plus:
- allow methods to take arguments
- not
- array literals
- hash literals
* range literals
* range flip-flops
* $_ (or does this belong in language support above?)
- while
* unless
* until
- next, redo, break in while and until loops
- allow blocks to be defined and yielded to
- multiple assignment
- tests for block arg options (scatter, gather etc)
* tests for singleton method definition
- case statements

Bugs
====
* Failing tests in
	* testStackAndJumps
	* testRescue2
	* testRescue3
	* testSuper
	* testClasses
	* testConsts
* cross-refs between the Bytecode::Writer::*Manager classes are ugly

Interpreter infrastructure
==========================
- declare bytecode format in Ruby
- Bytecode::Writer should calculate number of locals
* memory leaks
- per-frame stacks? (yes - necessary for stack unwinding)
* bytecode dump and load
* string, integer literals
* declare bytecode effects in Ruby (like vmgen)
* experiment with registers and arg sets rather than stack?

Other guff
==========
- make Writer pretty print itself so eg blocks are indented
* move to Ruby 1.6.8
* move to Ruby 1.8.0
* change compilation options to use -Wall or similar
* document all methods using RDoc

Possible future optimisations
=============================
- optimise frames
	- allocate locals 'inline' with struct frame
	- allocate frames from a linear stack where possible (eg no block calls)
* avoid gotos in rescue statements - make exceptionless route jumpless
* inline various interpreter C functions
* threaded bytecode dispatch
* optimise argument handling for method calls
* optimise yield to not go through an array
* optimise a, b = b, a etc to not go through an intermediate array
* static optimisation of bytecodes
* macro bytecodes (dynamic optimisation)
* method lookup using displays
* bytecode for inline method dispatch on calls (though maybe swamped by bytecode dispatch overhead)
