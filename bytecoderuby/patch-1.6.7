--- eval.c	Wed Feb 27 04:50:29 2002
+++ eval.c	Sun Dec  1 14:59:26 2002
@@ -253,7 +253,7 @@
     return body;
 }
 
-static NODE*
+NODE*
 rb_get_method_body(klassp, idp, noexp)
     VALUE *klassp;
     ID *idp;
@@ -729,16 +729,6 @@
     ruby_iter = _iter.prev;		\
 }
 
-struct tag {
-    jmp_buf buf;
-    struct FRAME *frame;
-    struct iter *iter;
-    ID tag;
-    VALUE retval;
-    struct SCOPE *scope;
-    int dst;
-    struct tag *prev;
-};
 static struct tag *prot_tag;
 
 #define PUSH_TAG(ptag) {		\
@@ -3510,6 +3500,7 @@
 rb_block_given_p()
 {
     if (ruby_frame->iter) return Qtrue;
+    if (bcr_hooks.block_given_p && bcr_hooks.block_given_p()) return Qtrue;
     return Qfalse;
 }
 
@@ -3544,6 +3535,14 @@
     int state;
     static unsigned serial = 1;
 
+    if (bcr_hooks.yield) {
+      result = bcr_hooks.yield(val);
+      if (result != Qundef) { /* Qundef signals no-go for BCR */
+	return result;
+      }
+      result = Qnil;
+    }
+
     if (!rb_block_given_p()) {
 	rb_raise(rb_eLocalJumpError, "no block given");
     }
@@ -4050,6 +4049,7 @@
     return result;
 }
 
+
 VALUE
 rb_with_disable_interrupt(proc, data)
     VALUE (*proc)();
@@ -4237,7 +4237,7 @@
     }
 }
 
-static VALUE
+VALUE
 call_cfunc(func, recv, len, argc, argv)
     VALUE (*func)();
     VALUE recv;
@@ -4395,6 +4395,15 @@
 	    }
 	}
 	break;
+      case NODE_BFUNC:
+	{
+	  if (!bcr_hooks.call) {
+	    rb_raise(rb_eStandardError, "bytecode extensions not loaded");
+	  }
+	  
+	  result = (*bcr_hooks.call)(body->nd_cfnc, recv, argc, argv);
+	}
+	break;
 
 	/* for attr get/set */
       case NODE_IVAR:
@@ -4562,7 +4571,40 @@
     return result;
 }
 
-static VALUE
+NODE *
+rb_get_method_body_in_cache(klass, recv, mid, argc, argv, scope)
+    VALUE klass, recv;
+    ID    mid;
+    int argc;			/* OK */
+    VALUE *argv;		/* OK */
+    int scope;
+{
+    NODE  *body;		/* OK */
+    int    noex;
+    ID     id = mid;
+    struct cache_entry *ent;
+
+    if (!klass) {
+	rb_raise(rb_eNotImpError, "method call on terminated object");
+    }
+    /* is it in the method cache? */
+    ent = cache + EXPR1(klass, mid);
+    if (ent->mid == mid && ent->klass == klass) {
+      if (!ent->method)
+	/* FIXME this isn't right! */
+	return (NODE *) rb_undefined(recv, mid, argc, argv, 
+				     scope==2?CSTAT_VCALL:0);
+      klass = ent->origin;
+      id    = ent->mid0; // FIXME - don't understand this yet
+      noex  = ent->noex;
+      body  = ent->method;
+      return body;
+    } else {
+      return 0;
+    }
+}
+
+VALUE
 rb_call(klass, recv, mid, argc, argv, scope)
     VALUE klass, recv;
     ID    mid;
@@ -8989,6 +9031,8 @@
     rb_define_method(cThGroup, "list", thgroup_list, 0);
     rb_define_method(cThGroup, "add", thgroup_add, 1);
     rb_define_const(cThGroup, "Default", thgroup_s_new(0, 0, cThGroup));
+
+    memset(&bcr_hooks, 0, sizeof(bcr_hooks));
 }
 
 static VALUE
@@ -9090,4 +9134,38 @@
 	}
 	tt = tt->prev;
     }
+}
+
+
+void
+bc_push_tag(struct tag *_tag) {
+
+  _tag->retval = Qnil;		     
+  _tag->frame = ruby_frame;		
+  _tag->iter = ruby_iter;		
+  _tag->prev = prot_tag;		
+  _tag->scope = ruby_scope;		
+  //  _tag->tag = ptag;			
+  _tag->dst = 0;			
+
+  //  _tag->prev = prot_tag;
+  prot_tag  = _tag;
+}
+
+
+void 
+bc_pop_tag(struct tag *_tag) {
+  prot_tag = _tag->prev;
+}
+
+
+void 
+bc_jump_tag(int state) {
+  JUMP_TAG(state);
+}
+
+
+VALUE
+bc_current_exception() {
+  return ruby_errinfo;
 }
--- node.h	Wed Feb 27 04:50:30 2002
+++ node.h	Mon Apr  1 13:53:34 2002
@@ -121,6 +121,7 @@
     NODE_DMETHOD,
     NODE_BMETHOD,
     NODE_MEMO,
+    NODE_BFUNC,
     NODE_LAST
 };
 
--- ruby.h	Tue Feb 26 13:08:17 2002
+++ ruby.h	Fri Nov 29 22:05:16 2002
@@ -618,6 +618,31 @@
 #define rb_sys_stat stat
 #endif
 
+/* Hooks for ByteCodeRuby */
+typedef VALUE (*BCRCall) _(( void *code, VALUE recv, int argc, VALUE *argv ));
+
+struct bcr_hooks {
+
+  BCRCall call;
+  VALUE (*yield)         _(( VALUE val ));
+  int   (*block_given_p) _(( void ));
+
+} bcr_hooks;
+
+#include <setjmp.h>
+
+struct tag {
+    jmp_buf buf;
+    struct FRAME *frame;
+    struct iter *iter;
+    ID tag;
+    VALUE retval;
+    struct SCOPE *scope;
+    int dst;
+    struct tag *prev;
+};
+
+
 #if defined(__cplusplus)
 }  /* extern "C" { */
 #endif
